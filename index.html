<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chat - Lo-fi Prototype</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            height: 100vh;
            overflow: hidden;
        }

        /* Main Container */
        .app-container {
            display: flex;
            height: 100vh;
            position: relative;
        }

        /* Side Navigation */
        .side-nav {
            width: 280px;
            height: 100vh;
            background-color: white;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            transition: width 0.3s ease;
            overflow-y: auto;
            flex-shrink: 0;
            width: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            z-index: 100;
        }

        /* Mobile view - add rounded corners */
        .mobile-view .side-nav {
            border-radius: 20px 0 0 20px;
        }

        .side-nav.active {
            width: 280px;
        }

        .nav-header {
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .nav-content {
            flex: 1;
            overflow-y: auto;
        }

        .nav-item {
            padding: 8px 20px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 14px;
        }

        .nav-item:hover {
            background-color: #f5f5f5;
        }

        .nav-section-title {
            padding: 16px 20px 8px;
            font-size: 14px;
            text-transform: uppercase;
            color: #666;
            font-weight: 600;
        }

        /* Documentation Cards */
        .doc-card {
            padding: 12px;
            background-color: #f8f9fa;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            height: 72px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .doc-card:hover {
            background-color: #e9ecef;
        }

        .doc-card-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }

        .doc-card-subtitle {
            font-size: 12px;
            color: #666;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }


        /* Chat Container */
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: relative;
        }

        /* Chat Header */
        .chat-header {
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }

        .chat-header-actions {
            display: none;
            align-items: center;
            gap: 12px;
        }

        .has-messages .chat-header-actions {
            display: flex;
        }

        .header-icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            background-color: transparent;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .header-icon:hover {
            background-color: rgba(0,0,0,0.05);
        }

        .burger-menu {
            width: 30px;
            height: 30px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            padding: 5px;
            z-index: 100;
        }

        .burger-line {
            width: 100%;
            height: 2px;
            background-color: #333;
            transition: all 0.3s ease;
        }

        .messages-area {
            flex: 1;
            overflow-y: auto;
            padding: 20px 180px;
            padding-bottom: 140px;
            padding-top: 20px;
        }

        /* Mobile view - reduce padding */
        .mobile-view .messages-area {
            padding: 20px 20px 140px 20px !important;
        }

        .mobile-view .section-nav {
            display: none !important;
        }

        .message {
            margin-bottom: 20px;
        }

        .message-content {
            padding: 12px 16px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .message.user .message-content {
            background-color: #007AFF;
            color: white;
        }

        /* Research Response Styling */
        .research-response .message-content {
            max-width: none;
            padding: 0;
            background-color: transparent;
            box-shadow: none;
        }

        .research-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .research-content {
            flex: 1;
        }

        .research-header h1 {
            margin: 0 0 20px 0;
            color: #000;
            font-size: 32px;
            font-weight: 700;
            line-height: 1.2;
        }

        .research-question {
            margin: 0 0 30px 0;
            padding: 16px 20px;
            background-color: #f5f5f5;
            border: none;
            border-radius: 0;
            font-size: 14px;
            color: #666;
        }

        .research-answer {
            font-size: 16px;
            line-height: 1.6;
            color: #333;
        }

        .research-answer h2 {
            margin: 30px 0 15px 0;
            color: #000;
            font-size: 24px;
            font-weight: 600;
        }

        .research-answer h3 {
            margin: 25px 0 12px 0;
            color: #000;
            font-size: 20px;
            font-weight: 600;
        }

        .research-answer p {
            margin: 0 0 16px 0;
        }

        .research-answer ul {
            margin: 0 0 16px 0;
            padding-left: 24px;
        }

        .research-answer li {
            margin-bottom: 8px;
        }

        /* Section Navigation */
        .section-nav {
            width: 200px;
            position: sticky;
            top: 80px;
            display: none;
        }

        @media (min-width: 1200px) {
            .section-nav {
                display: block;
            }
        }

        .section-nav-title {
            font-size: 12px;
            text-transform: uppercase;
            color: #666;
            margin-bottom: 12px;
            font-weight: 600;
        }

        .section-nav-item {
            padding: 8px 12px;
            margin-bottom: 4px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            color: #666;
            transition: all 0.2s;
        }

        .section-nav-item:hover {
            background-color: #f0f0f0;
            color: #333;
        }

        .section-nav-item.active {
            background-color: #e8f0fe;
            color: #1967d2;
            font-weight: 500;
        }

        /* Input Area */
        .input-container {
            position: fixed;
            bottom: 50%;
            left: 50%;
            transform: translate(-50%, 50%);
            z-index: 50;
            width: 90%;
            max-width: 600px;
            transition: all 0.3s ease;
        }

        /* Input at bottom when messages exist */
        .has-messages .input-container {
            bottom: 20px;
            transform: translateX(-50%);
        }

        .side-nav.active ~ .chat-container .input-container {
            left: calc(50% + 140px);
            margin-left: 10px;
        }

        /* Input positioning with nav active and messages */
        .side-nav.active ~ .chat-container.has-messages .input-container {
            left: calc(50% + 140px);
            margin-left: 10px;
        }

        .input-wrapper {
            max-width: 800px;
            margin: 0 auto;
        }

        .input-box {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            background-color: white;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 12px;
            min-height: 100px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .file-upload-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: transparent;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: background-color 0.2s;
            align-self: flex-start;
        }

        .file-upload-btn:hover {
            background-color: rgba(0,0,0,0.05);
        }

        .file-input {
            display: none;
        }

        .chat-input {
            flex: 1;
            border: none;
            background: none;
            outline: none;
            font-size: 16px;
            padding: 0;
            min-height: 72px;
            max-height: 120px;
            resize: none;
        }

        .send-button {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: #007AFF;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: background-color 0.2s;
        }

        .send-button:hover {
            background-color: #0056b3;
        }

        .send-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        /* File Preview */
        .file-preview {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background-color: rgba(0,0,0,0.05);
            border-radius: 8px;
            margin: 8px 0 0 0;
            font-size: 14px;
        }

        .file-remove {
            cursor: pointer;
            color: #666;
            margin-left: 8px;
        }

        /* User Profile Section */
        .user-profile-section {
            background-color: #f8f8f8;
            border-top: 1px solid #e0e0e0;
            margin-top: auto;
        }

        .user-profile {
            display: flex;
            align-items: center;
            padding: 16px;
            gap: 12px;
            cursor: pointer;
            position: relative;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #007AFF;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
        }

        .user-info {
            flex: 1;
        }

        .user-name {
            font-weight: 600;
            font-size: 14px;
        }

        .user-email {
            font-size: 12px;
            color: #666;
        }


        /* View Toggle Button */
        .view-toggle {
            position: fixed;
            right: 20px;
            top: 65px;
            background-color: white;
            border: 1px solid #e0e0e0;
            border-radius: 20px;
            padding: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .toggle-option {
            width: 36px;
            height: 36px;
            border: none;
            background-color: transparent;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .toggle-option.active {
            background-color: #007AFF;
            color: white;
        }

        .toggle-option:hover:not(.active) {
            background-color: #f0f0f0;
        }

        /* Device Dropdown */
        .device-dropdown {
            position: absolute;
            right: 0;
            top: calc(100% + 4px);
            background-color: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            min-width: 180px;
            display: none;
            z-index: 1001;
        }

        .device-dropdown.active {
            display: block;
        }

        .device-option {
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            border-bottom: 1px solid #f0f0f0;
        }

        .device-option:first-child {
            border-radius: 8px 8px 0 0;
        }

        .device-option:last-child {
            border-bottom: none;
            border-radius: 0 0 8px 8px;
        }

        .device-option:hover {
            background-color: #f5f5f5;
        }

        .device-option.selected {
            background-color: #007AFF;
            color: white;
        }

        .device-name {
            font-weight: 500;
            font-size: 14px;
        }

        .device-size {
            font-size: 12px;
            color: #666;
            margin-top: 2px;
        }

        .device-option.selected .device-size {
            color: rgba(255,255,255,0.8);
        }

        /* Mobile View Styles */
        .mobile-view {
            max-width: 390px;
            margin: 0 auto;
            border: 1px solid #ccc;
            border-radius: 20px;
            overflow: hidden;
            position: relative;
            transition: max-width 0.3s ease;
        }

        .mobile-view .app-container {
            border-radius: 20px;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .side-nav.active {
                width: 85vw;
            }
            
            .side-nav.active ~ .chat-container .input-container {
                left: calc(50% + 42.5vw);
            }
            
            .input-container {
                width: 95%;
                max-width: none;
            }
        }

        /* Mobile View Input Background */
        .mobile-view .input-background {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 140px;
            background-color: #f5f5f5;
            z-index: 40;
        }

        /* Mobile View Specific Responsive */
        .mobile-view .input-container {
            position: absolute !important;
            bottom: 60px !important;
            left: 20px !important;
            right: 20px !important;
            width: auto !important;
            max-width: none !important;
            margin: 0 !important;
            transform: none !important;
            padding: 0 !important;
            z-index: 50 !important;
        }

        .mobile-view .side-nav.active ~ .chat-container .input-container {
            display: none !important;
        }

        .mobile-view .side-nav.active ~ .chat-container .input-background {
            display: none !important;
        }

        .mobile-view .side-nav.active ~ .chat-container .messages-area {
            display: none !important;
        }

        .mobile-view .side-nav.active ~ .chat-container .chat-header {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- View Toggle Button -->
    <div class="view-toggle">
        <button class="toggle-option active" id="desktopToggle" onclick="switchView('desktop')" title="Desktop View">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
                <line x1="8" y1="21" x2="16" y2="21"></line>
                <line x1="12" y1="17" x2="12" y2="21"></line>
            </svg>
        </button>
        <div style="position: relative;">
            <button class="toggle-option" id="mobileToggle" onclick="toggleMobileView()" title="Mobile View">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect>
                    <line x1="12" y1="18" x2="12.01" y2="18"></line>
                </svg>
            </button>
            
            <div class="device-dropdown" id="deviceDropdown">
                <div class="device-option selected" onclick="selectDevice('iphone14', 390)">
                    <div class="device-name">iPhone 14</div>
                    <div class="device-size">390 × 844px</div>
                </div>
                <div class="device-option" onclick="selectDevice('pixel7', 412)">
                    <div class="device-name">Pixel 7</div>
                    <div class="device-size">412 × 915px</div>
                </div>
            </div>
        </div>
    </div>

    <div class="app-container" id="appContainer">
        <!-- Side Navigation -->
        <nav class="side-nav active" id="sideNav">
            <div class="nav-header">
                <div style="display: flex; align-items: center; gap: 12px; flex: 1;">
                    <div style="width: 40px; height: 40px; background-color: #007AFF; border-radius: 8px;"></div>
                    <div style="padding: 4px 12px; background-color: rgba(255,255,255,0.2); border: 1px solid rgba(0,0,0,0.1); border-radius: 20px; font-size: 12px; color: #666;">Alpha</div>
                </div>
                <button onclick="newChat()" style="width: 36px; height: 36px; border-radius: 8px; background-color: #f0f0f0; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 20px; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#e0e0e0'" onmouseout="this.style.backgroundColor='#f0f0f0'">+</button>
            </div>
            
            <div class="nav-content">
                <div style="margin-top: 24px;"></div>
                <div class="nav-section-title">ASKS</div>
            <div class="nav-item" onclick="loadChat('Morning conversation')">Morning conversation</div>
            <div class="nav-item" onclick="loadChat('Project discussion')">Project discussion</div>
            <div class="nav-item" onclick="loadChat('Code review')">Code review</div>
            <div class="nav-item" onclick="loadChat('Design ideas')">Design ideas</div>
            <div class="nav-item" onclick="loadChat('API documentation')">API documentation</div>
            <div class="nav-item" onclick="loadChat('Database schema')">Database schema</div>
            </div>
            
            <!-- Documentation Cards -->
            <div style="padding: 16px 20px;">
                <div class="doc-card" onclick="openDocs('getting-started')">
                    <div class="doc-card-title">Getting started with Asks</div>
                    <div class="doc-card-subtitle">Learn how to make the most of Caesar.</div>
                </div>
                <div class="doc-card" onclick="openDocs('api')" style="margin-top: 12px;">
                    <div class="doc-card-title">Caesar API</div>
                    <div class="doc-card-subtitle">Access the API docs</div>
                </div>
            </div>
            
            <!-- User Profile Section -->
            <div class="user-profile-section">
                <div class="user-profile">
                    <div class="user-avatar">JH</div>
                    <div class="user-info">
                        <div class="user-name">John Hughes</div>
                        <div class="user-email">john@example.com</div>
                    </div>
                    <button onclick="openSettings()" style="width: 32px; height: 32px; border-radius: 8px; background-color: transparent; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(0,0,0,0.1)'" onmouseout="this.style.backgroundColor='transparent'">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="5" cy="12" r="1"></circle>
                            <circle cx="12" cy="12" r="1"></circle>
                            <circle cx="19" cy="12" r="1"></circle>
                        </svg>
                    </button>
                </div>
            </div>
        </nav>

        <!-- Chat Container -->
        <div class="chat-container">
            <!-- Chat Header -->
            <div class="chat-header">
                <div class="burger-menu" onclick="toggleSideNav()">
                    <div class="burger-line"></div>
                    <div class="burger-line"></div>
                    <div class="burger-line"></div>
                </div>
                
                <div class="chat-header-actions">
                    <button class="header-icon" onclick="shareChat()" title="Share">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path>
                            <polyline points="16,6 12,2 8,6"></polyline>
                            <line x1="12" y1="2" x2="12" y2="15"></line>
                        </svg>
                    </button>
                    <button class="header-icon" onclick="openChatMenu()" title="Menu">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="1"></circle>
                            <circle cx="12" cy="5" r="1"></circle>
                            <circle cx="12" cy="19" r="1"></circle>
                        </svg>
                    </button>
                </div>
            </div>
            
            <div class="messages-area" id="messagesArea">
            </div>

            <!-- Mobile Input Background -->
            <div class="input-background"></div>

            <!-- Input Container -->
            <div class="input-container">
                <div class="input-wrapper">
                    <div class="input-box">
                        <textarea 
                            class="chat-input" 
                            id="chatInput" 
                            placeholder="Ask anything"
                            rows="3"
                            onkeydown="handleKeyPress(event)"
                            oninput="autoResize(this)"
                        ></textarea>
                        <div id="filePreview"></div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <button class="file-upload-btn" onclick="document.getElementById('fileInput').click()">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
                                </svg>
                            </button>
                            <button class="send-button" id="sendButton" onclick="sendMessage()">
                                ➤
                            </button>
                        </div>
                        <input type="file" id="fileInput" class="file-input" multiple onchange="handleFileSelect(event)">
                    </div>
                </div>
                <div style="text-align: center; margin-top: 12px; font-size: 12px; color: #999;">
                    Caesar can make mistakes. Please double-check responses.
                </div>
            </div>
        </div>
    </div>

    <script>
        let selectedFiles = [];

        function toggleSideNav() {
            const sideNav = document.getElementById('sideNav');
            sideNav.classList.toggle('active');
        }

        // Auto-focus input on load
        window.addEventListener('load', function() {
            document.getElementById('chatInput').focus();
        });

        function loadChat(chatName) {
            const messagesArea = document.getElementById('messagesArea');
            const chatContainer = document.querySelector('.chat-container');
            const appContainer = document.getElementById('appContainer');
            
            // Check if we're in mobile view mode
            const isMobileView = appContainer.parentElement.classList.contains('mobile-view');
            
            // Close navigation in mobile view
            if (isMobileView) {
                toggleSideNav();
            }
            
            // Add has-messages class to move input to bottom
            chatContainer.classList.add('has-messages');
            
            // Sample conversation for the selected chat with Caesar's deep research format
            const sampleResponses = {
                'Morning conversation': {
                    question: 'What are the latest developments in quantum computing and how will they impact cryptography?',
                    response: `
                        <div class="research-container">
                            <div class="research-content">
                                <div class="research-header">
                                    <h1>Quantum Computing Breakthroughs and Cryptographic Implications</h1>
                                </div>
                                
                                <div class="research-question">
                                    What are the latest developments in quantum computing and how will they impact cryptography?
                                </div>
                                
                                <div class="research-answer">
                                    <h2>Recent Quantum Computing Milestones</h2>
                                    <p>The quantum computing landscape has experienced remarkable progress in 2024, with several groundbreaking achievements that bring us closer to practical quantum advantage.</p>
                                    
                                    <h3>IBM's 1000+ Qubit Systems</h3>
                                    <p>IBM announced its Condor processor with 1,121 superconducting qubits, marking a significant milestone in scaling quantum systems. The processor demonstrates improved error rates through advanced error mitigation techniques, achieving coherence times exceeding 200 microseconds.</p>
                                    
                                    <h3>Google's Error Correction Breakthrough</h3>
                                    <p>Google's Quantum AI team achieved a major breakthrough in quantum error correction using their surface code implementation. They demonstrated that increasing the size of their logical qubits from 17 to 49 physical qubits reduced the error rate by a factor of 2.14, proving that quantum error correction can work in practice.</p>
                                    
                                    <h2>Impact on Current Cryptographic Systems</h2>
                                    <p>The advancement of quantum computing poses an existential threat to many cryptographic protocols currently securing global communications and data.</p>
                                    
                                    <h3>RSA and Elliptic Curve Vulnerability</h3>
                                    <p>Shor's algorithm, when run on a sufficiently powerful quantum computer, can factor large integers and compute discrete logarithms in polynomial time. Current estimates suggest that breaking RSA-2048 would require approximately 20 million noisy qubits or 4,000 error-corrected logical qubits. With current progress, this threshold could be reached within 10-15 years.</p>
                                    
                                    <h3>Timeline for Cryptographic Threats</h3>
                                    <p>The "Y2Q" moment - when quantum computers can break current encryption - is estimated by experts to occur between 2030 and 2040. However, "harvest now, decrypt later" attacks mean that sensitive data encrypted today could be vulnerable when quantum computers become available.</p>
                                    
                                    <h2>Post-Quantum Cryptography Solutions</h2>
                                    <p>In response to quantum threats, the cryptographic community has developed new algorithms resistant to quantum attacks.</p>
                                    
                                    <h3>NIST Standardization</h3>
                                    <p>The National Institute of Standards and Technology (NIST) finalized its first set of post-quantum cryptographic standards in 2024, including CRYSTALS-Kyber for key encapsulation and CRYSTALS-Dilithium for digital signatures. These algorithms are based on mathematical problems believed to be difficult even for quantum computers.</p>
                                    
                                    <h3>Implementation Challenges</h3>
                                    <p>Post-quantum algorithms typically require larger key sizes and more computational resources. For example, CRYSTALS-Kyber public keys are 800-1,568 bytes compared to 256-bit ECC keys at 64 bytes. This presents challenges for resource-constrained devices and requires careful optimization.</p>
                                </div>
                            </div>
                            
                            <div class="section-nav">
                                <div class="section-nav-title">On this page</div>
                                <div class="section-nav-item active">Recent Quantum Computing Milestones</div>
                                <div class="section-nav-item">Impact on Current Cryptographic Systems</div>
                                <div class="section-nav-item">Post-Quantum Cryptography Solutions</div>
                            </div>
                        </div>
                    `
                },
                'Project discussion': {
                    question: 'How do modern web frameworks compare for building scalable SaaS applications?',
                    response: `
                        <div class="research-container">
                            <div class="research-content">
                                <div class="research-header">
                                    <h1>Comprehensive Analysis of Modern Web Frameworks for SaaS Development</h1>
                                </div>
                                
                                <div class="research-question">
                                    How do modern web frameworks compare for building scalable SaaS applications?
                                </div>
                                
                                <div class="research-answer">
                                    <h2>Framework Performance Benchmarks</h2>
                                    <p>Recent benchmarks from TechEmpower and real-world SaaS deployments provide insights into framework performance at scale.</p>
                                    
                                    <h3>Request Handling Performance</h3>
                                    <p>Next.js 14 with App Router demonstrates exceptional performance, handling 45,000 requests per second in production environments with server components. Remix achieves similar throughput at 42,000 RPS with its nested routing architecture. Traditional SPAs using React or Vue typically max out around 25,000 RPS due to client-side rendering overhead.</p>
                                    
                                    <h3>Time to First Byte (TTFB)</h3>
                                    <p>Server-side rendering frameworks show significant advantages: Next.js averages 50-100ms TTFB, while Nuxt 3 achieves 60-120ms. Client-side frameworks require 200-400ms for initial bundle download plus rendering time. Edge runtime deployments can reduce TTFB to under 30ms globally.</p>
                                    
                                    <h2>Developer Experience and Productivity</h2>
                                    <p>Framework choice significantly impacts development velocity and team satisfaction in SaaS environments.</p>
                                    
                                    <h3>Type Safety and Developer Tools</h3>
                                    <p>TypeScript-first frameworks like Next.js, Remix, and SvelteKit provide end-to-end type safety. T3 Stack (TypeScript, tRPC, Tailwind) has gained adoption for its exceptional DX, with teams reporting 40% faster feature development. Prisma integration provides type-safe database access, eliminating runtime errors.</p>
                                    
                                    <h3>Learning Curve Analysis</h3>
                                    <p>Vue.js maintains the gentlest learning curve with its template-based approach. React requires understanding hooks and state management patterns. Svelte's compiler-based approach is intuitive but requires adjusting to its reactive declarations. Angular's steep learning curve is offset by its comprehensive tooling for enterprise teams.</p>
                                    
                                    <h2>Scalability Patterns and Architecture</h2>
                                    <p>Different frameworks excel at different scaling challenges faced by growing SaaS applications.</p>
                                    
                                    <h3>Horizontal Scaling Capabilities</h3>
                                    <p>Stateless frameworks like Next.js and Nuxt scale horizontally with ease on platforms like Vercel or Netlify. Remix's loader pattern naturally distributes data fetching across edge nodes. Traditional SPAs require careful API gateway design but offer more flexibility in backend scaling.</p>
                                    
                                    <h3>Multi-tenant Architecture Support</h3>
                                    <p>Next.js middleware excels at tenant isolation through URL rewriting and header manipulation. Django + React combinations provide mature multi-tenant database patterns. Laravel + Inertia.js offers built-in tenant scoping with minimal configuration.</p>
                                    
                                    <h2>Cost Analysis for SaaS Operations</h2>
                                    <p>Infrastructure and operational costs vary significantly between framework choices.</p>
                                    
                                    <h3>Hosting and Infrastructure Costs</h3>
                                    <p>Serverless frameworks reduce costs for variable traffic: Next.js on Vercel scales to zero, costing $0 during idle periods. Traditional deployments on AWS EC2 require minimum $50-200/month. Edge functions cost approximately $0.50 per million requests, making them cost-effective for global SaaS.</p>
                                    
                                    <h3>Development and Maintenance Costs</h3>
                                    <p>Full-stack frameworks reduce team size requirements. Companies report needing 2-3 developers with Next.js versus 4-5 for separate frontend/backend stacks. Automated deployment pipelines in modern frameworks save 10-15 hours per developer monthly.</p>
                                </div>
                            </div>
                            
                            <div class="section-nav">
                                <div class="section-nav-title">On this page</div>
                                <div class="section-nav-item active">Framework Performance Benchmarks</div>
                                <div class="section-nav-item">Developer Experience and Productivity</div>
                                <div class="section-nav-item">Scalability Patterns and Architecture</div>
                                <div class="section-nav-item">Cost Analysis for SaaS Operations</div>
                            </div>
                        </div>
                    `
                },
                'Code review': {
                    question: 'What are the best practices for implementing secure authentication in 2024?',
                    response: `
                        <div class="research-container">
                            <div class="research-content">
                                <div class="research-header">
                                    <h1>Modern Authentication Security: 2024 Best Practices and Implementation Guide</h1>
                                </div>
                                
                                <div class="research-question">
                                    What are the best practices for implementing secure authentication in 2024?
                                </div>
                                
                                <div class="research-answer">
                                    <h2>Passwordless Authentication Standards</h2>
                                    <p>The authentication landscape in 2024 has shifted dramatically toward passwordless methods, driven by security breaches and user experience demands.</p>
                                    
                                    <h3>WebAuthn and Passkeys Implementation</h3>
                                    <p>WebAuthn has become the gold standard for passwordless authentication. Apple, Google, and Microsoft's coordinated passkey support means 95% of users can now authenticate without passwords. Implementation requires FIDO2-compliant servers and careful attention to account recovery flows. Passkeys reduce account takeover incidents by 99.9% compared to password-based systems.</p>
                                    
                                    <h3>Magic Link Security Considerations</h3>
                                    <p>Magic links remain popular for user onboarding but require careful implementation. Links must expire within 15 minutes, be single-use, and include rate limiting. Consider implementing risk-based authentication that requires additional verification for suspicious login patterns. Always use cryptographically secure random tokens of at least 32 bytes.</p>
                                    
                                    <h2>Multi-Factor Authentication Evolution</h2>
                                    <p>MFA has evolved beyond SMS OTP to more secure and user-friendly methods.</p>
                                    
                                    <h3>Biometric Integration Patterns</h3>
                                    <p>Device-based biometrics through WebAuthn provide seamless MFA. Implement fallback mechanisms for devices without biometric capabilities. Privacy regulations require explicit consent and local biometric processing - never transmit biometric data to servers. Success rates exceed 99.5% with proper implementation.</p>
                                    
                                    <h3>Risk-Based Adaptive Authentication</h3>
                                    <p>Modern systems analyze login context including device fingerprinting, location, time patterns, and behavioral biometrics. Suspicious activities trigger step-up authentication. Machine learning models can reduce false positives to under 0.1% while catching 95% of account takeover attempts.</p>
                                    
                                    <h2>Session Management Best Practices</h2>
                                    <p>Secure session handling is critical for maintaining authentication security post-login.</p>
                                    
                                    <h3>Token Rotation and Storage</h3>
                                    <p>Implement refresh token rotation with detection of token reuse. Access tokens should expire within 15 minutes for sensitive applications. Store tokens in httpOnly, secure, sameSite cookies to prevent XSS attacks. For mobile apps, use platform-specific secure storage (iOS Keychain, Android Keystore).</p>
                                    
                                    <h3>Distributed Session Handling</h3>
                                    <p>Microservices architectures require careful session synchronization. JWT tokens with short expiration provide stateless authentication but require careful key management. Consider using Redis with encryption at rest for centralized session storage. Implement session invalidation webhooks for immediate revocation across services.</p>
                                    
                                    <h2>Compliance and Privacy Requirements</h2>
                                    <p>Regulatory requirements shape authentication implementation in 2024.</p>
                                    
                                    <h3>GDPR and Global Privacy Laws</h3>
                                    <p>Authentication systems must support data portability and deletion. Implement privacy-preserving analytics that don't track individual users. Consent management must be granular and reversible. Consider zero-knowledge proofs for authentication without storing personal data.</p>
                                    
                                    <h3>Industry-Specific Requirements</h3>
                                    <p>Healthcare requires HIPAA-compliant authentication with audit trails. Financial services need PSD2 strong customer authentication (SCA) with dynamic linking. Government systems increasingly require PIV/CAC card integration or derived credentials. Each industry has specific session timeout and re-authentication requirements.</p>
                                </div>
                            </div>
                            
                            <div class="section-nav">
                                <div class="section-nav-title">On this page</div>
                                <div class="section-nav-item active">Passwordless Authentication Standards</div>
                                <div class="section-nav-item">Multi-Factor Authentication Evolution</div>
                                <div class="section-nav-item">Session Management Best Practices</div>
                                <div class="section-nav-item">Compliance and Privacy Requirements</div>
                            </div>
                        </div>
                    `
                },
                'Design ideas': {
                    question: 'How can AI be used to personalize user experiences in e-commerce?',
                    response: `
                        <div class="research-container">
                            <div class="research-content">
                                <div class="research-header">
                                    <h1>AI-Driven Personalization in E-commerce: Strategies and Implementation</h1>
                                </div>
                                
                                <div class="research-question">
                                    How can AI be used to personalize user experiences in e-commerce?
                                </div>
                                
                                <div class="research-answer">
                                    <h2>Recommendation Engine Architectures</h2>
                                    <p>Modern e-commerce platforms leverage sophisticated AI models to deliver personalized product recommendations that drive significant revenue increases.</p>
                                    
                                    <h3>Collaborative Filtering vs Deep Learning</h3>
                                    <p>While traditional collaborative filtering still works for established catalogs, deep learning models like Two-Tower neural networks outperform by 35% in cold-start scenarios. Amazon's latest recommendation system combines transformer architectures with graph neural networks, processing user behavior sequences and product relationships simultaneously. This hybrid approach increased click-through rates by 24% compared to previous methods.</p>
                                    
                                    <h3>Real-Time Personalization Pipelines</h3>
                                    <p>Streaming architectures using Apache Kafka and Flink enable sub-50ms recommendation updates. Feature stores like Feast or Tecton maintain user profiles with 100+ real-time signals including browsing patterns, cart abandonment, and price sensitivity. GPU-accelerated inference servers handle millions of predictions per second, essential for Black Friday scale.</p>
                                    
                                    <h2>Dynamic Pricing and Inventory Optimization</h2>
                                    <p>AI enables sophisticated pricing strategies that maximize revenue while maintaining customer satisfaction.</p>
                                    
                                    <h3>Personalized Pricing Models</h3>
                                    <p>Reinforcement learning algorithms optimize prices based on individual price elasticity, competitor monitoring, and inventory levels. Walmart's pricing AI adjusts 50 million prices daily, achieving 3-5% margin improvements. Ethical considerations require transparency - showing price history and avoiding discriminatory practices. A/B testing frameworks must account for network effects and cannibalization.</p>
                                    
                                    <h3>Demand Forecasting Integration</h3>
                                    <p>Prophet and LightGBM models predict demand at SKU-location level with 85% accuracy for 30-day horizons. Incorporating external signals like weather, events, and social media trends improves accuracy by 12%. Automated reordering systems prevent stockouts while minimizing carrying costs, particularly crucial for perishable goods.</p>
                                    
                                    <h2>Conversational Commerce and AI Assistants</h2>
                                    <p>Natural language interfaces are transforming how customers discover and purchase products.</p>
                                    
                                    <h3>Visual Search and Discovery</h3>
                                    <p>Computer vision models using EfficientNet architectures enable "shop the look" features with 92% accuracy. Pinterest's Shop the Look processes 600 million searches monthly. Multi-modal transformers combine text queries with images, understanding requests like "shoes similar to these but in blue." Implementation requires careful image preprocessing and CDN optimization for mobile users.</p>
                                    
                                    <h3>Conversational AI Implementation</h3>
                                    <p>Large language models fine-tuned on product catalogs provide natural shopping assistants. RAG (Retrieval Augmented Generation) architectures ensure accurate product information while maintaining conversational flow. Successful implementations see 40% higher conversion rates compared to traditional search. Key challenges include handling multi-turn conversations and graceful fallbacks to human agents.</p>
                                    
                                    <h2>Personalization Ethics and Privacy</h2>
                                    <p>Balancing personalization benefits with user privacy remains a critical challenge.</p>
                                    
                                    <h3>Privacy-Preserving Techniques</h3>
                                    <p>Federated learning enables personalization without centralizing user data. Apple's on-device recommendations process 98% of personalization locally. Differential privacy adds mathematical guarantees against individual identification while maintaining model utility. Homomorphic encryption allows computation on encrypted user data, though computational overhead remains challenging at scale.</p>
                                    
                                    <h3>Transparency and User Control</h3>
                                    <p>GDPR and CCPA compliance requires explainable AI for personalization decisions. Shopify's "Why am I seeing this?" feature increased trust scores by 22%. User dashboards should allow preference editing, data deletion, and personalization opt-outs. Consider progressive disclosure of AI involvement to maintain the "magic" while building trust.</p>
                                </div>
                            </div>
                            
                            <div class="section-nav">
                                <div class="section-nav-title">On this page</div>
                                <div class="section-nav-item active">Recommendation Engine Architectures</div>
                                <div class="section-nav-item">Dynamic Pricing and Inventory</div>
                                <div class="section-nav-item">Conversational Commerce</div>
                                <div class="section-nav-item">Personalization Ethics</div>
                            </div>
                        </div>
                    `
                },
                'API documentation': {
                    question: 'What are the key principles of designing RESTful APIs that scale?',
                    response: `
                        <div class="research-container">
                            <div class="research-content">
                                <div class="research-header">
                                    <h1>Scalable RESTful API Design: Architecture Patterns and Best Practices</h1>
                                </div>
                                
                                <div class="research-question">
                                    What are the key principles of designing RESTful APIs that scale?
                                </div>
                                
                                <div class="research-answer">
                                    <h2>Resource Design and URL Structure</h2>
                                    <p>Well-designed resource models form the foundation of scalable REST APIs, impacting performance and developer experience.</p>
                                    
                                    <h3>Hierarchical Resource Modeling</h3>
                                    <p>Stripe's API demonstrates exemplary resource design with clear parent-child relationships: /v1/customers/{id}/subscriptions. This hierarchy enables efficient caching and authorization. Avoid deep nesting beyond 3 levels - flatten with resource expansion instead. GitHub's API allows ?expand=owner,collaborators to reduce round trips by 70%.</p>
                                    
                                    <h3>Versioning Strategies</h3>
                                    <p>URL versioning (/v1/, /v2/) remains most popular, used by 73% of public APIs. However, content negotiation via Accept headers provides more flexibility. Stripe's approach of maintaining all versions indefinitely with clear deprecation timelines has become the gold standard. Implement version transformation layers to minimize code duplication across versions.</p>
                                    
                                    <h2>Performance Optimization Techniques</h2>
                                    <p>High-traffic APIs require sophisticated optimization strategies beyond basic caching.</p>
                                    
                                    <h3>Pagination and Data Windowing</h3>
                                    <p>Cursor-based pagination outperforms offset/limit at scale - Discord's API handles billions of messages using snowflake IDs as cursors. Implement consistent pagination with hasMore flags and next tokens. For real-time feeds, consider timestamp-based windowing with long-polling or Server-Sent Events. Response compression with Brotli reduces payload sizes by 25% compared to gzip.</p>
                                    
                                    <h3>Caching Strategies</h3>
                                    <p>Multi-layer caching dramatically improves performance: CDN edge caching for static resources, Redis for hot data, and database query caching. ETags enable conditional requests, reducing bandwidth by 80% for unchanged resources. Cache invalidation via webhooks or event streams maintains consistency. Consider stale-while-revalidate patterns for non-critical data.</p>
                                    
                                    <h2>Rate Limiting and Traffic Management</h2>
                                    <p>Protecting API infrastructure while ensuring fair access requires sophisticated rate limiting.</p>
                                    
                                    <h3>Adaptive Rate Limiting</h3>
                                    <p>Token bucket algorithms provide flexible rate limiting - Twitter uses 15-minute windows with burst allowances. Implement graduated limits based on authentication level, with higher limits for paid tiers. Return X-RateLimit headers for client awareness. Consider cost-based limiting where expensive operations consume more quota than simple reads.</p>
                                    
                                    <h3>Circuit Breakers and Graceful Degradation</h3>
                                    <p>Netflix's Hystrix patterns prevent cascade failures - circuit breakers trip after 50% error rate over 20 requests. Implement fallbacks for non-critical features and partial responses for degraded services. Health check endpoints should reflect downstream dependencies. Use exponential backoff with jitter for retry logic to prevent thundering herds.</p>
                                    
                                    <h2>Security and Authentication Patterns</h2>
                                    <p>API security requires defense in depth with multiple layers of protection.</p>
                                    
                                    <h3>OAuth 2.0 and JWT Best Practices</h3>
                                    <p>Implement OAuth 2.0 with PKCE for public clients, preventing authorization code interception. JWT tokens should use RS256 signing with key rotation every 90 days. Include minimal claims to reduce token size - store extended permissions in backend caches. Refresh token rotation with breach detection prevents long-term token compromise.</p>
                                    
                                    <h3>API Gateway Security</h3>
                                    <p>Kong, Apigee, or AWS API Gateway provide centralized security enforcement. Implement request signing for sensitive operations - AWS Signature Version 4 prevents replay attacks. Rate limit by API key AND IP address to prevent distributed attacks. GraphQL APIs require query depth limiting and cost analysis to prevent resource exhaustion.</p>
                                </div>
                            </div>
                            
                            <div class="section-nav">
                                <div class="section-nav-title">On this page</div>
                                <div class="section-nav-item active">Resource Design and URL Structure</div>
                                <div class="section-nav-item">Performance Optimization</div>
                                <div class="section-nav-item">Rate Limiting and Traffic</div>
                                <div class="section-nav-item">Security and Authentication</div>
                            </div>
                        </div>
                    `
                },
                'Database schema': {
                    question: 'How do you design a database schema for a multi-tenant SaaS application?',
                    response: `
                        <div class="research-container">
                            <div class="research-content">
                                <div class="research-header">
                                    <h1>Multi-Tenant Database Architecture: Design Patterns and Implementation Strategies</h1>
                                </div>
                                
                                <div class="research-question">
                                    How do you design a database schema for a multi-tenant SaaS application?
                                </div>
                                
                                <div class="research-answer">
                                    <h2>Tenant Isolation Strategies</h2>
                                    <p>Choosing the right isolation level impacts security, performance, and operational complexity throughout your application's lifecycle.</p>
                                    
                                    <h3>Database-per-Tenant Architecture</h3>
                                    <p>Complete isolation provides maximum security and customization flexibility. Salesforce uses this approach for enterprise clients, managing over 100,000 separate databases. Automated provisioning via Terraform or CloudFormation is essential. Connection pooling becomes critical - implement a smart router that maintains pools per tenant. This approach supports compliance requirements like HIPAA and SOC 2 but increases operational overhead by 10x.</p>
                                    
                                    <h3>Schema-per-Tenant Design</h3>
                                    <p>PostgreSQL schemas offer good isolation with lower overhead than separate databases. Atlassian's Confluence uses this pattern, supporting 50,000+ tenants per database instance. Implement row-level security (RLS) as an additional safety layer. Schema migrations require careful orchestration - use tools like Flyway with parallel execution. Monitor schema object limits carefully as PostgreSQL has a 32TB size limit per database.</p>
                                    
                                    <h3>Shared Schema with Row-Level Security</h3>
                                    <p>Most cost-effective for high-volume B2C applications. Shopify processes 1M+ requests/second using shared schemas with tenant_id columns. Implement composite indexes (tenant_id, primary_key) for all tables. Use database features like PostgreSQL's Row Level Security or MySQL's connection attributes for automatic filtering. This approach scales to millions of tenants but requires rigorous testing to prevent data leaks.</p>
                                    
                                    <h2>Performance Optimization Patterns</h2>
                                    <p>Multi-tenant architectures face unique performance challenges requiring specialized solutions.</p>
                                    
                                    <h3>Indexing Strategies</h3>
                                    <p>Composite indexes with tenant_id as the leading column are crucial for query performance. Implement partial indexes for tenant-specific data patterns - Zendesk reduced query time by 85% using partial indexes. Consider BRIN indexes for time-series data in PostgreSQL, reducing index size by 95%. Monitor index bloat in high-churn environments and schedule regular REINDEX operations during off-peak hours.</p>
                                    
                                    <h3>Sharding and Partitioning</h3>
                                    <p>Horizontal sharding by tenant_id enables linear scaling. Discord shards by guild_id across 1000+ database instances. Implement consistent hashing for shard assignment to minimize data movement during scaling. Table partitioning by date improves performance for time-series data - partition monthly data older than 90 days. Use pg_partman or native partitioning for automated partition management.</p>
                                    
                                    <h2>Data Migration and Schema Evolution</h2>
                                    <p>Schema changes in multi-tenant environments require careful planning and execution.</p>
                                    
                                    <h3>Zero-Downtime Migrations</h3>
                                    <p>GitHub's scientist pattern enables testing new schemas in production without risk. Implement dual-write patterns during transitions, writing to both old and new schemas. Use feature flags to gradually migrate read traffic. For large tables, use pt-online-schema-change or gh-ost for non-blocking alterations. Plan for 3x storage during migrations and monitor replication lag carefully.</p>
                                    
                                    <h3>Tenant-Specific Customizations</h3>
                                    <p>EAV (Entity-Attribute-Value) patterns enable custom fields but impact performance. JSONB columns in PostgreSQL provide better performance for semi-structured data. Implement a metadata service to track custom fields per tenant. Consider separate extension tables for custom data to maintain query performance on core tables. Limit customizations to prevent schema explosion - Salesforce limits custom objects to 2000 per tenant.</p>
                                    
                                    <h2>Backup and Disaster Recovery</h2>
                                    <p>Multi-tenant architectures require sophisticated backup strategies balancing cost and recovery objectives.</p>
                                    
                                    <h3>Tenant-Level Backup Strategies</h3>
                                    <p>Implement logical backups using pg_dump with --schema flags for PostgreSQL schema isolation. For shared schemas, use COPY commands with WHERE clauses for tenant-specific exports. Continuous archiving with point-in-time recovery enables tenant-specific restores. Store backups in immutable object storage with lifecycle policies. Test restore procedures monthly - Netflix's chaos engineering includes backup failure scenarios.</p>
                                    
                                    <h3>Cross-Region Replication</h3>
                                    <p>Multi-region deployments require careful consistency management. Use PostgreSQL logical replication for selective tenant replication. Implement conflict resolution strategies for multi-master setups. CockroachDB or YugabyteDB provide distributed SQL with built-in multi-region support. Monitor replication lag per tenant and implement automatic failover with health checks. Consider regulatory requirements for data residency when designing replication topology.</p>
                                </div>
                            </div>
                            
                            <div class="section-nav">
                                <div class="section-nav-title">On this page</div>
                                <div class="section-nav-item active">Tenant Isolation Strategies</div>
                                <div class="section-nav-item">Performance Optimization</div>
                                <div class="section-nav-item">Data Migration and Evolution</div>
                                <div class="section-nav-item">Backup and Recovery</div>
                            </div>
                        </div>
                    `
                }
            };
            
            const chatData = sampleResponses[chatName] || {
                question: `What is ${chatName.toLowerCase()}?`,
                response: `
                    <div class="research-container">
                        <div class="research-content">
                            <div class="research-header">
                                <h1>${chatName} Analysis</h1>
                            </div>
                            
                            <div class="research-question">
                                What is ${chatName.toLowerCase()}?
                            </div>
                            
                            <div class="research-answer">
                                <h2>Overview</h2>
                                <p>This is a sample deep research response for "${chatName}". In a real application, Caesar would provide comprehensive, well-structured analysis with multiple sections, citations, and detailed explanations.</p>
                                
                                <h2>Key Components</h2>
                                <p>Caesar's responses typically include historical context, current applications, technical details, and future implications of the topic being researched.</p>
                                
                                <h2>Research Methodology</h2>
                                <p>Each response is generated through analysis of multiple sources, fact-checking, and structured presentation to provide maximum value to the user.</p>
                            </div>
                        </div>
                        
                        <div class="section-nav">
                            <div class="section-nav-title">On this page</div>
                            <div class="section-nav-item active">Overview</div>
                            <div class="section-nav-item">Key Components</div>
                            <div class="section-nav-item">Research Methodology</div>
                        </div>
                    </div>
                `
            };
            
            messagesArea.innerHTML = `
                <div class="message ai research-response">
                    <div class="message-content">
                        ${chatData.response}
                    </div>
                </div>
            `;
            
            // Scroll to bottom
            messagesArea.scrollTop = messagesArea.scrollHeight;
        }

        function newChat() {
            toggleSideNav();
            const messagesArea = document.getElementById('messagesArea');
            const chatContainer = document.querySelector('.chat-container');
            messagesArea.innerHTML = '';
            // Remove has-messages class to center input again
            chatContainer.classList.remove('has-messages');
        }

        function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            selectedFiles = [...selectedFiles, ...files];
            updateFilePreview();
        }

        function updateFilePreview() {
            const filePreview = document.getElementById('filePreview');
            filePreview.innerHTML = selectedFiles.map((file, index) => `
                <div class="file-preview">
                    📄 ${file.name}
                    <span class="file-remove" onclick="removeFile(${index})">✕</span>
                </div>
            `).join('');
        }

        function removeFile(index) {
            selectedFiles.splice(index, 1);
            updateFilePreview();
        }

        function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (message || selectedFiles.length > 0) {
                const messagesArea = document.getElementById('messagesArea');
                const chatContainer = document.querySelector('.chat-container');
                
                // Add has-messages class to move input to bottom
                chatContainer.classList.add('has-messages');
                
                // Store the message for the response (but don't display it as a blue bubble)
                
                // Clear input and files
                input.value = '';
                selectedFiles = [];
                updateFilePreview();
                autoResize(input);
                
                // Simulate AI response
                setTimeout(() => {
                    const aiResponse = `
                        <div class="message ai research-response">
                            <div class="message-content">
                                <div class="research-container">
                                    <div class="research-content">
                                        <div class="research-header">
                                            <h1>Response Analysis</h1>
                                        </div>
                                        
                                        <div class="research-question">
                                            ${message}
                                        </div>
                                        
                                        <div class="research-answer">
                                            <p>I've received your message${selectedFiles.length > 0 ? ' and files' : ''}. This is a demo response. In a real application, Caesar would provide a comprehensive, well-structured analysis with multiple sections based on deep research.</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    messagesArea.insertAdjacentHTML('beforeend', aiResponse);
                    messagesArea.scrollTop = messagesArea.scrollHeight;
                }, 1000);
                
                messagesArea.scrollTop = messagesArea.scrollHeight;
            }
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        function autoResize(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
        }

        function openSettings() {
            alert('Settings clicked - would open settings panel');
        }

        function openDocs(type) {
            if (type === 'getting-started') {
                alert('Opening Getting Started docs...');
            } else if (type === 'api') {
                alert('Opening API docs...');
            }
        }

        function shareChat() {
            alert('Share chat functionality - would open share options');
        }

        function openChatMenu() {
            alert('Chat menu - would show options like rename, delete, export, etc.');
        }

        let currentDevice = { name: 'iphone14', width: 390 };

        function switchView(viewType) {
            const appContainer = document.getElementById('appContainer');
            const desktopToggle = document.getElementById('desktopToggle');
            const mobileToggle = document.getElementById('mobileToggle');
            const deviceDropdown = document.getElementById('deviceDropdown');
            
            if (viewType === 'mobile') {
                appContainer.parentElement.classList.add('mobile-view');
                appContainer.parentElement.style.maxWidth = currentDevice.width + 'px';
                desktopToggle.classList.remove('active');
                mobileToggle.classList.add('active');
            } else {
                appContainer.parentElement.classList.remove('mobile-view');
                appContainer.parentElement.style.maxWidth = '';
                desktopToggle.classList.add('active');
                mobileToggle.classList.remove('active');
                deviceDropdown.classList.remove('active');
            }
        }

        function toggleMobileView() {
            const appContainer = document.getElementById('appContainer');
            const deviceDropdown = document.getElementById('deviceDropdown');
            
            if (appContainer.parentElement.classList.contains('mobile-view')) {
                // If already in mobile view, toggle dropdown
                deviceDropdown.classList.toggle('active');
            } else {
                // Switch to mobile view
                switchView('mobile');
                // Show dropdown
                setTimeout(() => {
                    deviceDropdown.classList.add('active');
                }, 100);
            }
        }

        function selectDevice(deviceName, width) {
            const appContainer = document.getElementById('appContainer');
            const deviceDropdown = document.getElementById('deviceDropdown');
            
            // Update current device
            currentDevice = { name: deviceName, width: width };
            
            // Update mobile view width
            if (appContainer.parentElement.classList.contains('mobile-view')) {
                appContainer.parentElement.style.maxWidth = width + 'px';
            }
            
            // Update selected state in dropdown
            document.querySelectorAll('.device-option').forEach(option => {
                option.classList.remove('selected');
            });
            event.target.closest('.device-option').classList.add('selected');
            
            // Close dropdown
            deviceDropdown.classList.remove('active');
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const deviceDropdown = document.getElementById('deviceDropdown');
            const mobileToggle = document.getElementById('mobileToggle');
            
            if (!mobileToggle.contains(event.target) && !deviceDropdown.contains(event.target)) {
                deviceDropdown.classList.remove('active');
            }
        });
    </script>
</body>
</html>